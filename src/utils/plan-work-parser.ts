/**
 * Plan Work Parser
 *
 * Types and utilities for the "Plan Work" workflow.
 * Handles parsing AI responses and applying tasks/slices to project files.
 */

// ============================================================================
// Types
// ============================================================================

/**
 * Enrichment content for a planned task
 */
export interface PlannedTaskEnrichment {
  why: string
  considerations: string[]
  acceptance: string[]
  constraints: string[]
}

/**
 * A task generated by the Plan Work workflow
 */
export interface PlannedTask {
  id: string
  text: string
  sliceLink: string | null
  isNewSlice: boolean
  enrichment: PlannedTaskEnrichment
  selected: boolean // User selection state
}

/**
 * A new slice suggested by the Plan Work workflow
 */
export interface SuggestedSlice {
  id: string
  vsNumber: string
  name: string
  milestone: string | null
  purpose: string
  delivers: string
  solves: string
  selected: boolean // User selection state
}

/**
 * User's final decision for a planned task
 */
export interface PlannedTaskSelection {
  taskId: string
  selected: boolean
  destination: 'current' | 'later' | 'discard'
}

/**
 * User's final decision for a suggested slice
 */
export interface SuggestedSliceSelection {
  sliceId: string
  selected: boolean
}

/**
 * AI response format for plan-work workflow
 */
export interface PlanWorkAIResponse {
  tasks: Array<{
    text: string
    sliceLink?: string
    isNewSlice: boolean
    enrichment: {
      why: string
      considerations: string[]
      acceptance: string[]
      constraints?: string[]
    }
  }>
  newSlices?: Array<{
    id: string
    name: string
    milestone?: string
    purpose: string
    delivers: string
    solves: string
  }>
  summary: {
    tasksGenerated: number
    existingSlicesLinked: number
    newSlicesSuggested: number
    notes?: string
  }
}

/**
 * Summary info extracted from a plan-work response
 */
export interface PlanWorkSummary {
  tasksGenerated: number
  existingSlicesLinked: number
  newSlicesSuggested: number
  notes: string | null
}

// ============================================================================
// Detection Functions
// ============================================================================

/**
 * Check if a message contains plan-work JSON response
 */
export function containsPlanWorkResponse(content: string): boolean {
  return (
    content.includes('"tasks"') &&
    content.includes('"enrichment"') &&
    content.includes('"why"') &&
    content.includes('"acceptance"')
  )
}

// ============================================================================
// Parsing Functions
// ============================================================================

/**
 * Parse AI JSON response into PlannedTask and SuggestedSlice arrays
 */
export function parsePlanWorkResponse(aiResponse: string): {
  tasks: PlannedTask[]
  slices: SuggestedSlice[]
  summary: PlanWorkSummary | null
} {
  try {
    // Extract JSON from the response (it might be wrapped in markdown code blocks)
    let jsonStr = aiResponse.trim()

    // Try to extract JSON from code blocks
    const jsonMatch = jsonStr.match(/```(?:json)?\s*([\s\S]*?)```/)
    if (jsonMatch) {
      jsonStr = jsonMatch[1].trim()
    }

    const parsed: PlanWorkAIResponse = JSON.parse(jsonStr)

    if (!parsed.tasks || !Array.isArray(parsed.tasks)) {
      console.warn('Plan work response missing tasks array')
      return { tasks: [], slices: [], summary: null }
    }

    const tasks: PlannedTask[] = parsed.tasks.map((item, index) => ({
      id: `plan-task-${index}`,
      text: item.text,
      sliceLink: item.sliceLink || null,
      isNewSlice: item.isNewSlice || false,
      enrichment: {
        why: item.enrichment.why,
        considerations: item.enrichment.considerations || [],
        acceptance: item.enrichment.acceptance || [],
        constraints: item.enrichment.constraints || [],
      },
      selected: true, // Default to selected
    }))

    const slices: SuggestedSlice[] = (parsed.newSlices || []).map((item, index) => ({
      id: `plan-slice-${index}`,
      vsNumber: item.id,
      name: item.name,
      milestone: item.milestone || null,
      purpose: item.purpose,
      delivers: item.delivers,
      solves: item.solves,
      selected: true, // Default to selected
    }))

    const summary: PlanWorkSummary | null = parsed.summary
      ? {
          tasksGenerated: parsed.summary.tasksGenerated ?? tasks.length,
          existingSlicesLinked: parsed.summary.existingSlicesLinked ?? 0,
          newSlicesSuggested: parsed.summary.newSlicesSuggested ?? slices.length,
          notes: parsed.summary.notes || null,
        }
      : null

    return { tasks, slices, summary }
  } catch (error) {
    console.error('Failed to parse plan work response:', error)
    return { tasks: [], slices: [], summary: null }
  }
}

/**
 * Extract summary info from a plan-work JSON response
 */
export function extractPlanWorkSummary(content: string): PlanWorkSummary | null {
  try {
    let jsonStr = content.trim()

    // Try to extract JSON from code blocks
    const jsonMatch = jsonStr.match(/```(?:json)?\s*([\s\S]*?)```/)
    if (jsonMatch) {
      jsonStr = jsonMatch[1].trim()
    }

    const parsed = JSON.parse(jsonStr)

    if (parsed.summary) {
      return {
        tasksGenerated: parsed.summary.tasksGenerated ?? 0,
        existingSlicesLinked: parsed.summary.existingSlicesLinked ?? 0,
        newSlicesSuggested: parsed.summary.newSlicesSuggested ?? 0,
        notes: parsed.summary.notes || null,
      }
    }

    // Fallback: count tasks if no summary provided
    if (parsed.tasks && Array.isArray(parsed.tasks)) {
      return {
        tasksGenerated: parsed.tasks.length,
        existingSlicesLinked: parsed.tasks.filter((t: { sliceLink?: string; isNewSlice?: boolean }) => t.sliceLink && !t.isNewSlice).length,
        newSlicesSuggested: (parsed.newSlices || []).length,
        notes: null,
      }
    }

    return null
  } catch {
    return null
  }
}

// ============================================================================
// Formatting Functions
// ============================================================================

/**
 * Format a planned task as markdown with enrichment blockquote
 */
export function formatPlannedTask(task: PlannedTask): string {
  const lines: string[] = []

  // Task line with optional slice link
  let taskLine = `- [ ] ${task.text}`
  if (task.sliceLink) {
    taskLine += ` ${task.sliceLink}`
  }
  lines.push(taskLine)

  // Enrichment block
  lines.push('')
  lines.push(`> **Why:** ${task.enrichment.why}`)

  if (task.enrichment.considerations.length > 0) {
    lines.push('> **Considerations:**')
    for (const consideration of task.enrichment.considerations) {
      lines.push(`> - ${consideration}`)
    }
  }

  if (task.enrichment.acceptance.length > 0) {
    lines.push('> **Acceptance:**')
    for (const criterion of task.enrichment.acceptance) {
      lines.push(`> - ${criterion}`)
    }
  }

  if (task.enrichment.constraints.length > 0) {
    lines.push(`> **Constraints:** ${task.enrichment.constraints.join('; ')}`)
  }

  lines.push('')

  return lines.join('\n')
}

/**
 * Format a suggested slice as markdown for Roadmap.md
 */
export function formatSuggestedSlice(slice: SuggestedSlice): string {
  const lines: string[] = []

  lines.push(`#### ${slice.vsNumber} â€” ${slice.name}`)
  lines.push('')
  lines.push(`**Purpose:** ${slice.purpose}`)
  lines.push('')
  lines.push(`**Delivers:** ${slice.delivers}`)
  lines.push('')
  lines.push(`**Solves:** ${slice.solves}`)
  lines.push('')

  return lines.join('\n')
}

// ============================================================================
// Apply Functions
// ============================================================================

/**
 * Apply selected tasks to Tasks.md content
 */
export function applyPlannedTasks(
  tasksContent: string,
  tasks: PlannedTask[],
  selections: PlannedTaskSelection[]
): string {
  // Build a map of selections
  const selectionMap = new Map(selections.map((s) => [s.taskId, s]))

  // Separate tasks by destination
  const currentTasks: PlannedTask[] = []
  const laterTasks: PlannedTask[] = []

  for (const task of tasks) {
    const selection = selectionMap.get(task.id)
    if (!selection || !selection.selected || selection.destination === 'discard') {
      continue
    }

    if (selection.destination === 'current') {
      currentTasks.push(task)
    } else if (selection.destination === 'later') {
      laterTasks.push(task)
    }
  }

  if (currentTasks.length === 0 && laterTasks.length === 0) {
    return tasksContent
  }

  let result = tasksContent

  // Add to Current section
  if (currentTasks.length > 0) {
    result = addTasksToSection(result, currentTasks, 'current')
  }

  // Add to Later section
  if (laterTasks.length > 0) {
    result = addTasksToSection(result, laterTasks, 'later')
  }

  return result
}

/**
 * Add tasks to a specific section in Tasks.md
 */
function addTasksToSection(
  content: string,
  tasks: PlannedTask[],
  section: 'current' | 'later'
): string {
  const sectionPattern = section === 'current'
    ? /^(##\s*(?:Current|Now).*?)(?=\n##|\n*$)/ims
    : /^(##\s*(?:Later|Future).*?)(?=\n##|\n*$)/ims

  const match = content.match(sectionPattern)

  if (match) {
    // Section exists - append tasks to it
    const sectionContent = match[1]
    const formattedTasks = tasks.map(formatPlannedTask).join('\n')

    // Check if section ends with content or just the header
    const endsWithNewlines = /\n\s*$/.test(sectionContent)
    const separator = endsWithNewlines ? '' : '\n\n'

    const newSectionContent = sectionContent + separator + formattedTasks
    return content.replace(sectionPattern, newSectionContent)
  } else {
    // Section doesn't exist - create it
    const sectionHeader = section === 'current' ? '## Current' : '## Later'
    const formattedTasks = tasks.map(formatPlannedTask).join('\n')

    // Find where to insert (before the first ## if possible)
    const firstSectionMatch = content.match(/^##\s/m)
    if (firstSectionMatch && firstSectionMatch.index !== undefined) {
      return (
        content.slice(0, firstSectionMatch.index) +
        `${sectionHeader}\n\n${formattedTasks}\n\n` +
        content.slice(firstSectionMatch.index)
      )
    }

    // No sections exist - append to end
    return content.trimEnd() + `\n\n${sectionHeader}\n\n${formattedTasks}\n`
  }
}

/**
 * Apply selected slices to Roadmap.md content
 */
export function applySuggestedSlices(
  roadmapContent: string,
  slices: SuggestedSlice[],
  selections: SuggestedSliceSelection[]
): string {
  // Build a map of selected slices
  const selectedSlices = slices.filter((slice) => {
    const selection = selections.find((s) => s.sliceId === slice.id)
    return selection?.selected ?? false
  })

  if (selectedSlices.length === 0) {
    return roadmapContent
  }

  let result = roadmapContent

  for (const slice of selectedSlices) {
    result = addSliceToRoadmap(result, slice)
  }

  return result
}

/**
 * Add a single slice to Roadmap.md
 */
function addSliceToRoadmap(content: string, slice: SuggestedSlice): string {
  const formattedSlice = formatSuggestedSlice(slice)

  // Try to find the milestone to add the slice under
  if (slice.milestone) {
    const milestonePattern = new RegExp(
      `^(###\\s*${escapeRegExp(slice.milestone)}.*?)(?=\n###|\\n*$)`,
      'ims'
    )
    const match = content.match(milestonePattern)

    if (match) {
      // Add slice at the end of the milestone section
      const milestoneContent = match[1]
      const newMilestoneContent = milestoneContent.trimEnd() + '\n\n' + formattedSlice
      return content.replace(milestonePattern, newMilestoneContent)
    }
  }

  // No specific milestone or milestone not found - add before "---" or at end
  const dividerMatch = content.match(/\n---\s*\n/)
  if (dividerMatch && dividerMatch.index !== undefined) {
    return (
      content.slice(0, dividerMatch.index) +
      '\n\n' +
      formattedSlice +
      content.slice(dividerMatch.index)
    )
  }

  // Append to end
  return content.trimEnd() + '\n\n' + formattedSlice
}

/**
 * Escape special regex characters in a string
 */
function escapeRegExp(string: string): string {
  return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
}

// ============================================================================
// Utility Functions
// ============================================================================

/**
 * Get the next available VS number from existing Roadmap content
 */
export function getNextVSNumber(roadmapContent: string): string {
  const vsPattern = /VS(\d+)/g
  let maxNumber = 0
  let match

  while ((match = vsPattern.exec(roadmapContent)) !== null) {
    const num = parseInt(match[1], 10)
    if (num > maxNumber) {
      maxNumber = num
    }
  }

  return `VS${maxNumber + 1}`
}

/**
 * Check if a slice link already exists in Roadmap.md
 */
export function sliceExistsInRoadmap(roadmapContent: string, sliceLink: string): boolean {
  // Extract the VS ID from the link
  const vsMatch = sliceLink.match(/VS\d+/)
  if (!vsMatch) return false

  // Check if this VS ID exists in the roadmap
  return roadmapContent.includes(vsMatch[0])
}
